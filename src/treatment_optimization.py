# -*- coding: utf-8 -*-
"""treatment_optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ulNmayJhkKsGilja2DrNEpL6KT7sJl-W
"""

# treatment_optimization.py

from datetime import datetime, timedelta
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import gridspec
from typing import List, Dict, Tuple, Optional

class TreatmentOptimizer:
    def __init__(self):
        """Initialize treatment optimizer with QoL metrics and timing parameters."""
        self.qol_metrics = self._define_qol_metrics()
        self.treatment_timing = self._define_treatment_timing()
        self.recovery_patterns = self._define_recovery_patterns()

    def _define_qol_metrics(self):
        """Define quality of life metrics and their weights."""
        return {
            'physical': {
                'mobility': {'weight': 0.2, 'scale': (0, 10)},
                'pain': {'weight': 0.2, 'scale': (0, 10)},
                'fatigue': {'weight': 0.15, 'scale': (0, 10)},
                'sleep': {'weight': 0.1, 'scale': (0, 10)}
            },
            'emotional': {
                'anxiety': {'weight': 0.1, 'scale': (0, 10)},
                'depression': {'weight': 0.1, 'scale': (0, 10)},
                'social_isolation': {'weight': 0.08, 'scale': (0, 10)}
            },
            'functional': {
                'daily_activities': {'weight': 0.15, 'scale': (0, 10)},
                'work_capability': {'weight': 0.12, 'scale': (0, 10)}
            }
        }

    def _define_treatment_timing(self):
        """Define timing constraints and preferences for treatments."""
        return {
            'Surgery': {
                'duration': 1,  # days
                'recovery_time': 30,  # days
                'optimal_sequence': 1,
                'required_gap_before': 14,
                'required_gap_after': 21,
                'qol_impact': {
                    'immediate': -0.8,
                    'recovery_rate': 0.03,
                    'long_term': -0.1
                }
            },
            'Chemotherapy': {
                'duration': 21,  # days per cycle
                'cycles': 6,
                'optimal_sequence': 2,
                'required_gap_before': 21,
                'required_gap_after': 14,
                'qol_impact': {
                    'immediate': -0.6,
                    'recovery_rate': 0.02,
                    'long_term': -0.2
                }
            },
            'Radiation': {
                'duration': 35,  # days
                'optimal_sequence': 3,
                'required_gap_before': 14,
                'required_gap_after': 14,
                'qol_impact': {
                    'immediate': -0.5,
                    'recovery_rate': 0.025,
                    'long_term': -0.15
                }
            },
            'Immunotherapy': {
                'duration': 14,  # days per cycle
                'cycles': 12,
                'optimal_sequence': 4,
                'required_gap_before': 21,
                'required_gap_after': 21,
                'qol_impact': {
                    'immediate': -0.3,
                    'recovery_rate': 0.04,
                    'long_term': -0.05
                }
            }
        }

    def _define_recovery_patterns(self):
        """Define recovery patterns and their impact on QoL."""
        return {
            'rapid': {
                'description': 'Quick initial recovery with steady improvement',
                'function': lambda t: 1 - np.exp(-0.1 * t)
             },
             'gradual': {
                'description': 'Steady, linear improvement over time',
                'function': lambda t: np.minimum(np.ones_like(t), 0.05 * t)
             },
             'delayed': {
                'description': 'Slow initial recovery with later acceleration',
                'function': lambda t: 1 - 1/(1 + 0.05 * t)
             }
        }

    def optimize_treatment_timing(self, treatments, patient_factors, start_date=None):
        """Optimize treatment timing based on various factors."""
        if start_date is None:
            start_date = datetime.now()

        schedule = []
        current_date = start_date
        total_duration = 0

        # Get age and health values with defaults
        patient_age = float(patient_factors.get('age', 0))  # Convert to float
        patient_health = float(patient_factors.get('general_health', 5))  # Convert to float

        sorted_treatments = sorted(treatments,
                                 key=lambda x: self.treatment_timing[x]['optimal_sequence'])

        for treatment in sorted_treatments:
            timing = self.treatment_timing[treatment]

            # Calculate optimal gap based on patient factors
            optimal_gap = timing['required_gap_before']
            # Use float comparisons instead of array comparisons
            if patient_age > 70:
                optimal_gap *= 1.2
            if patient_health < 3:
                optimal_gap *= 1.3

            # Add gap if not first treatment
            if schedule:
                current_date += timedelta(days=int(optimal_gap))

            # Calculate treatment duration
            duration = timing['duration']
            if 'cycles' in timing:
                duration *= timing['cycles']

            schedule.append({
                'treatment': treatment,
                'start_date': current_date,
                'end_date': current_date + timedelta(days=duration),
                'duration': duration,
                'required_gap_after': timing['required_gap_after']
            })

            current_date += timedelta(days=duration)
            total_duration += duration

        return schedule, total_duration

    def calculate_qol_impact(self, schedule, patient_factors, duration_days):
         """
         Calculate quality of life impact over time.

         Args:
             schedule: List of scheduled treatments
             patient_factors: Dictionary of patient characteristics
             duration_days: Total duration in days

         Returns:
            numpy.ndarray: Array of QoL scores over time
         """
         # Initialize QoL scores
         qol_scores = np.ones(duration_days)

         # Get resilience value with default
         patient_resilience = float(patient_factors.get('resilience', 5))

         for treatment in schedule:
             # Calculate indices
             start_idx = (treatment['start_date'] - schedule[0]['start_date']).days
             duration = treatment['duration']
             end_idx = start_idx + duration

             # Get timing info
             timing_info = self.treatment_timing[treatment['treatment']]

             # Calculate base impact
             impact = timing_info['qol_impact']['immediate']

             # Adjust impact based on resilience
             if patient_resilience > 7:
                impact *= 0.8
             elif patient_resilience < 3:
                impact *= 1.2

             try:
                # Create recovery pattern for exact duration
                t = np.arange(duration)
                recovery_pattern = self.recovery_patterns['gradual']['function'](t)

                # Calculate impact for this duration
                treatment_impact = np.full(duration, impact)
                qol_change = treatment_impact * (1 - recovery_pattern)

                # Apply the impact
                if start_idx < len(qol_scores) and end_idx <= len(qol_scores):
                    qol_scores[start_idx:end_idx] += qol_change

                # Apply long-term impact
                if end_idx < len(qol_scores):
                    qol_scores[end_idx:] += timing_info['qol_impact']['long_term']

             except Exception as e:
                print(f"Error processing treatment {treatment['treatment']}:")
                print(f"Duration: {duration}")
                print(f"Start index: {start_idx}")
                print(f"End index: {end_idx}")
                print(f"QoL scores length: {len(qol_scores)}")
                raise e

         # Ensure scores are between 0 and 1
         return np.clip(qol_scores, 0, 1)

    def analyze_qol_components(self, baseline_qol, treatment_schedule):
        """Analyze individual QoL components over time."""
        component_scores = {}

        for category, metrics in self.qol_metrics.items():
            category_scores = {}
            for metric, details in metrics.items():
                baseline = baseline_qol.get(f"{category}_{metric}", details['scale'][1] / 2)
                scores = []


                for treatment in treatment_schedule:
                    timing_info = self.treatment_timing[treatment['treatment']]
                    impact = timing_info['qol_impact']['immediate'] * details['weight']
                    recovery_rate = timing_info['qol_impact']['recovery_rate']

                    t = np.arange(treatment['duration'])
                    treatment_scores = baseline * (1 + impact * np.exp(-recovery_rate * t))
                    scores.extend(treatment_scores)

                category_scores[metric] = np.clip(scores,
                                                details['scale'][0],
                                                details['scale'][1])

            component_scores[category] = category_scores

        return component_scores

def visualize_treatment_timeline(optimizer, schedule, qol_scores):
    """Visualize treatment timeline and QoL impact."""
    fig = plt.figure(figsize=(20, 12))
    gs = gridspec.GridSpec(3, 1, height_ratios=[2, 1, 1])

    # Treatment Timeline
    ax1 = fig.add_subplot(gs[0])
    colors = plt.cm.Set3(np.linspace(0, 1, len(schedule)))

    for i, treatment in enumerate(schedule):
        start_date = treatment['start_date']
        duration = treatment['duration']

        ax1.barh(y=0, width=duration, left=(start_date - schedule[0]['start_date']).days,
                color=colors[i], label=treatment['treatment'])

    ax1.set_title('Treatment Timeline')
    ax1.set_xlabel('Days from Start')
    ax1.set_yticks([])
    ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))

    # QoL Score Timeline
    ax2 = fig.add_subplot(gs[1])
    ax2.plot(qol_scores, 'b-', label='Overall QoL')
    ax2.set_title('Quality of Life Score Over Time')
    ax2.set_xlabel('Days from Start')
    ax2.set_ylabel('QoL Score')
    ax2.grid(True)
    ax2.legend()

    # Recovery Patterns
    ax3 = fig.add_subplot(gs[2])
    t = np.linspace(0, 100, 100)
    for pattern_name, pattern in optimizer.recovery_patterns.items():
        ax3.plot(t, pattern['function'](t), label=pattern_name)

    ax3.set_title('Recovery Patterns')
    ax3.set_xlabel('Days')
    ax3.set_ylabel('Recovery Progress')
    ax3.grid(True)
    ax3.legend()

    plt.tight_layout()
    plt.show()